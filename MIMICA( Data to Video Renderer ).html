<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MIMICA Data to Video Renderer</title>
    <style>
        :root {
            --bg-color: #f0f2f5; --surface-color: #ffffff; --text-primary: #1c1e21;
            --text-secondary: #606770; --border-color: #e0e0e0; --accent-color: #007bff;
            --accent-text-color: #ffffff; --icon-filter: invert(10%);
        }

        [data-theme="dark"] {
            --bg-color: #121212; --surface-color: #1e1e1e; --text-primary: #e4e6eb;
            --text-secondary: #b0b3b8; --border-color: #393a3b; --accent-color: #00ff7f;
            --accent-text-color: #121212; --icon-filter: invert(95%);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color); color: var(--text-primary); font-size: 16px;
        }

        .app-container { display: flex; flex-direction: column; height: 100vh; width: 100vw; }
        .app-header { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem; background-color: var(--surface-color); border-bottom: 1px solid var(--border-color); }
        .app-header h1 { font-size: 1.1rem; color: var(--accent-color); }
        .status-indicators { display: flex; gap: 1rem; font-size: 0.8rem; color: var(--text-secondary); }
        .header-actions { display: flex; align-items: center; }

        .app-body { display: flex; flex: 1; overflow: hidden; }
        .main-content { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        
        .canvas-wrapper {
            background-color: #000; display: flex; justify-content: center; align-items: center;
            position: relative; min-height: 0; flex-grow: 1;
        }
        #motionCanvas { max-width: 100%; max-height: 100%; object-fit: contain; }
        
        .sidebar { background-color: var(--surface-color); padding: 1rem; overflow-y: auto; }
        .app-footer { padding: 0.5rem 1rem; text-align: center; font-size: 0.75rem; color: var(--text-secondary); background-color: var(--surface-color); border-top: 1px solid var(--border-color); }
        .app-footer a { color: var(--accent-color); text-decoration: none; }

        @media (max-width: 767px) {
            .app-body { flex-direction: column; }
            .sidebar { border-top: 1px solid var(--border-color); flex-shrink: 0; }
        }
        @media (min-width: 768px) {
            .app-body { flex-direction: row; }
            .sidebar { width: 350px; flex-shrink: 0; border-left: 1px solid var(--border-color); }
        }

        .control-section summary { font-size: 1.1rem; font-weight: 600; margin: 1rem 0 0.75rem; cursor: pointer; list-style: none; }
        .control-section summary::-webkit-details-marker { display: none; }
        .control-section summary::before { content: 'â–¶'; font-size: 0.8em; margin-right: 0.5rem; display: inline-block; transition: transform 0.2s; }
        details[open] > .control-section summary::before { transform: rotate(90deg); }
        .control-group { display: flex; flex-direction: column; gap: 0.75rem; padding-left: 0.5rem; }
        .checkbox-group label { display: flex; align-items: center; cursor: pointer; }
        
        input[type="file"] { display: none; }
        .file-label { display: flex; align-items: center; gap: 1rem; }
        .file-label .button { flex-shrink: 0; }
        #fileName, #statusText { font-size: 0.9rem; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #statusText { margin-top: 0.5rem; }

        .button, button, select { padding: 0.75rem; font-size: 1rem; font-weight: 600; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; text-align: center; background-color: var(--surface-color); color: var(--text-primary); }
        .button-primary { background-color: var(--accent-color); color: var(--accent-text-color); border-color: var(--accent-color); }
        
        .theme-toggle { background: none; border: none; cursor: pointer; padding: 0.5rem; }
        .theme-toggle svg { fill: var(--text-secondary); width: 24px; height: 24px; }
        
        /* --- Player Controls --- */
        .player-controls {
            position: absolute; bottom: 0; left: 0; right: 0;
            padding: 0.5rem 1rem;
            background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }
        .player-controls.hidden { opacity: 0; pointer-events: none; }
        .player-controls input[type="range"] { width: 100%; accent-color: var(--slider-track-color); }
        .bottom-controls { display: flex; justify-content: space-between; align-items: center; gap: 1rem; }
        .playback-buttons { display: flex; align-items: center; gap: 0.5rem; }
        .playback-buttons button, .settings-buttons button { background: none; border: none; padding: 0.5rem; }
        .playback-buttons button svg, .settings-buttons button svg { width: 24px; height: 24px; fill: #fff; }
        .playback-buttons button:disabled svg, .settings-buttons button:disabled svg { opacity: 0.4; }
        #playPauseBtn { width: 40px; height: 40px; }
        #playPauseBtn svg { width: 28px; height: 28px; }
        .settings-buttons { display: flex; align-items: center; gap: 0.5rem; }
        .settings-buttons select { background: none; border: 1px solid #fff; color: #fff; padding: 0.25rem 0.5rem; font-size: 0.8rem; }
        .settings-buttons option { background-color: var(--surface-color); color: var(--text-primary); }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <h1>MIMICA (Data to Video Renderer)</h1>
            <div class="status-indicators">
                <span id="timeText">Time: 00:00.000</span>
                <span id="frameText">Frame: 0 / 0</span>
            </div>
            <div class="header-actions">
                <button class="theme-toggle" id="themeToggle" title="Toggle Theme">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 9c-1.65 0-3 1.35-3 3s1.35 3 3 3 3-1.35 3-3-1.35-3-3-3m0 5c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1m8-5h-2.1c-.45-.78-1.07-1.4-1.82-1.82L17.9 4.36c-.39-.39-1.02-.39-1.41 0l-1.42 1.42C14.4 6.45 13.78 7.07 13 7.5V5c0-.55-.45-1-1-1s-1 .45-1 1v2.5c-.78.43-1.4.98-1.82 1.82L6.36 7.78c-.39-.39-1.02-.39-1.41 0l-1.42 1.42c-.39.39-.39 1.02 0 1.41l1.82 1.82c.43.78.98 1.4 1.82 1.82V19c0 .55.45 1 1 1s1-.45 1-1v-2.5c.78-.43 1.4-.98 1.82-1.82l1.82 1.82c.39.39 1.02.39 1.41 0l1.42-1.42c.39-.39.39-1.02 0-1.41l-1.82-1.82c-.43-.78-.98-1.4-1.82-1.82H20c.55 0 1-.45 1-1s-.45-1-1-1M12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5"/></svg>
                </button>
            </div>
        </header>

        <div class="app-body">
            <main class="main-content">
                <div class="canvas-wrapper">
                    <canvas id="motionCanvas"></canvas>
                    <div class="player-controls hidden">
                        <input type="range" id="timelineScrubber" value="0" min="0" max="100" step="1">
                        <div class="bottom-controls">
                            <div class="playback-buttons">
                                <button id="replayBtn" title="Replay (Stop)">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                                </button>
                                <button id="prevFrameBtn" title="Previous Frame">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6 8.5 6V6z"/></svg>
                                </button>
                                <button id="playPauseBtn" title="Play">
                                    <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                                    <svg id="pauseIcon" class="hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                                </button>
                                <button id="nextFrameBtn" title="Next Frame">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 18h2V6H6v12zm3.5-6L18 6v12z"/></svg>
                                </button>
                            </div>
                            <div class="settings-buttons">
                                <select id="speedControl">
                                    <option value="0.5">0.5x</option>
                                    <option value="1" selected>1x</option>
                                    <option value="2">2x</option>
                                </select>
                                <button id="fullscreenBtn" title="Toggle Fullscreen">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </main>
            <aside class="sidebar">
                 <details class="control-section" open>
                    <summary>Controls</summary>
                    <div class="control-group">
                        <label for="jsonFile" class="file-label">
                            <span class="button button-primary">Choose file</span>
                            <span id="fileName">No file chosen...</span>
                        </label>
                        <input type="file" id="jsonFile" accept=".json">
                        <span id="statusText">Load a MIMICA JSON file to begin.</span>
                    </div>
                </details>
                <details class="control-section" open>
                    <summary>Config</summary>
                    <div class="control-group checkbox-group">
                        <label><input type="checkbox" id="bodyStream" checked>Enable Body Tracking</label>
                        <label><input type="checkbox" id="handsStream" checked>Enable Hand Tracking</label>
                        <label><input type="checkbox" id="faceStream" checked>Enable Expression Recognition</label>
                        <label><input type="checkbox" id="mirrorMode">Mirror Mode</label>
                    </div>
                </details>
                
                <details class="control-section" open>
                    <summary>Export</summary>
                    <button id="exportBtn" class="button button-primary">Export WebM</button>
                </details>
            </aside>
        </div>

        <footer class="app-footer">
            <a href="https://dearnco.is-a.dev/" target="_blank" rel="noopener noreferrer">
                Made With LAAAV- By DEAR&CO |  contributing to the World Robotics and AI Community.
            </a>
        </footer>
    </div>

    <script type="module">
        class Renderer {
            constructor(canvas) { this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.lastFrame = null; this.lastOptions = null; this.defineSkeletons(); }
            defineSkeletons() { this.BODY_CONNECTIONS = [[11, 12], [23, 24], [11, 23], [12, 24], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20], [23, 25], [25, 27], [27, 29], [27, 31], [29, 31], [24, 26], [26, 28], [28, 30], [28, 32], [30, 32], [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10]]; this.HAND_CONNECTIONS = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]]; }
            resizeCanvas() { const container = this.canvas.parentElement; this.canvas.width = container.clientWidth; this.canvas.height = container.clientHeight; if (this.lastFrame && this.lastOptions) { this.drawFrame(this.lastFrame, this.lastOptions); } }
            drawFrame(frameData, options) { this.lastFrame = frameData; this.lastOptions = options; const { width, height } = this.canvas; this.ctx.clearRect(0, 0, width, height); this.ctx.save(); if (options.mirror) { this.ctx.translate(width, 0); this.ctx.scale(-1, 1); } if (options.drawBody && frameData.body && frameData.body.length > 0) { this.drawSkeleton(frameData.body, this.BODY_CONNECTIONS, 'rgba(0, 120, 255, 0.9)', 3); } if (options.drawHands && frameData.hands) { if (frameData.hands[0]) { this.drawSkeleton(frameData.hands[0], this.HAND_CONNECTIONS, 'rgba(255, 0, 120, 0.9)', 2); } if (frameData.hands[1]) { this.drawSkeleton(frameData.hands[1], this.HAND_CONNECTIONS, 'rgba(0, 255, 120, 0.9)', 2); } } if (options.drawFace && frameData.face && frameData.body && frameData.body.length > 0) { this.drawFaceText(frameData.face, frameData.body); } this.ctx.restore(); }
            drawSkeleton(landmarks, connections, color, lineWidth) { if (!landmarks || landmarks.length === 0) return; const { width, height } = this.canvas; this.ctx.strokeStyle = color; this.ctx.lineWidth = lineWidth; this.ctx.fillStyle = color; connections.forEach(([startIdx, endIdx]) => { if (startIdx < landmarks.length && endIdx < landmarks.length) { const start = landmarks[startIdx]; const end = landmarks[endIdx]; if (start && end) { this.ctx.beginPath(); this.ctx.moveTo(start.x * width, start.y * height); this.ctx.lineTo(end.x * width, end.y * height); this.ctx.stroke(); } } }); landmarks.forEach(point => { if (point) { const radius = Math.max(2, 6 * (1 - (point.z || 0.5))); this.ctx.beginPath(); this.ctx.arc(point.x * width, point.y * height, radius, 0, 2 * Math.PI); this.ctx.fill(); } }); }
            drawFaceText(text, bodyLandmarks) { if (!bodyLandmarks || bodyLandmarks.length === 0 || !text) return; const { width, height } = this.canvas; const nose = bodyLandmarks[0]; const leftShoulder = bodyLandmarks[11]; const rightShoulder = bodyLandmarks[12]; if (!nose || !leftShoulder || !rightShoulder) return; const shoulderWidth = Math.abs(leftShoulder.x - rightShoulder.x) * width; const fontSize = Math.max(16, Math.min(32, shoulderWidth / 5)); const x = nose.x * width; const y = (nose.y * height) - (fontSize * 2); this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary'); this.ctx.font = `bold ${fontSize}px sans-serif`; this.ctx.textAlign = 'center'; this.ctx.fillText(text.toUpperCase(), x, y); }
        }
        class Scheduler {
             constructor(onFrameUpdateCallback, onStateChangeCallback) { this.frames = []; this.onFrameUpdate = onFrameUpdateCallback; this.onStateChange = onStateChangeCallback; this.isPlaying = false; this.animationFrameId = null; this.playbackSpeed = 1.0; this.startTime = 0; this.pauseTime = 0; this.currentIndex = 0; this.onPlaybackComplete = null; }
            loadData(frames) { this.frames = frames; this.stop(); }
            play() { if (this.isPlaying || this.frames.length === 0) return; this.isPlaying = true; if (this.pauseTime > 0) { this.startTime += (performance.now() - this.pauseTime); } else { const offset = this.frames[this.currentIndex]?.timestamp || 0; this.startTime = performance.now() - (offset / this.playbackSpeed); } this.pauseTime = 0; this.animationFrameId = requestAnimationFrame(this._loop.bind(this)); this.onStateChange(); }
            playFromStart(onComplete) { this.stop(); this.onPlaybackComplete = onComplete; this.play(); }
            pause() { if (!this.isPlaying) return; this.isPlaying = false; this.pauseTime = performance.now(); cancelAnimationFrame(this.animationFrameId); this.onStateChange(); }
            stop() { this.isPlaying = false; if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); } this.startTime = 0; this.pauseTime = 0; this.currentIndex = 0; this.onPlaybackComplete = null; this.redrawCurrentFrame(); this.onStateChange(); }
            seek(frameIndex) { this.currentIndex = Math.max(0, Math.min(frameIndex, this.frames.length - 1)); const wasPlaying = this.isPlaying; if (wasPlaying) this.pause(); const offset = this.frames[this.currentIndex]?.timestamp || 0; this.startTime = performance.now() - (offset / this.playbackSpeed); this.pauseTime = performance.now(); this.redrawCurrentFrame(); if (wasPlaying) this.play(); }
            setSpeed(speed) { const wasPlaying = this.isPlaying; if (wasPlaying) this.pause(); const currentElapsedTime = (performance.now() - this.startTime) * this.playbackSpeed; this.playbackSpeed = speed; this.startTime = performance.now() - (currentElapsedTime / this.playbackSpeed); if (wasPlaying) this.play(); }
            redrawCurrentFrame() { if (this.frames.length > 0 && this.currentIndex < this.frames.length) { const state = { currentFrame: this.frames[this.currentIndex], currentTime: this.frames[this.currentIndex]?.timestamp || 0, currentIndex: this.currentIndex }; this.onFrameUpdate(state); } }
            _loop(timestamp) { if (!this.isPlaying) return; const elapsedTime = (timestamp - this.startTime) * this.playbackSpeed; while (this.currentIndex < this.frames.length - 1 && this.frames[this.currentIndex + 1].timestamp <= elapsedTime) { this.currentIndex++; } if (this.currentIndex >= this.frames.length - 1 || !this.frames[this.currentIndex + 1]) { this.currentIndex = this.frames.length - 1; this.redrawCurrentFrame(); this.stop(); if (this.onPlaybackComplete) { this.onPlaybackComplete(); this.onPlaybackComplete = null; } return; } const frame1 = this.frames[this.currentIndex]; const frame2 = this.frames[this.currentIndex + 1]; const t = (elapsedTime - frame1.timestamp) / (frame2.timestamp - frame1.timestamp); const interpolatedFrame = this._interpolate(frame1, frame2, t); const state = { currentFrame: interpolatedFrame, currentTime: elapsedTime, currentIndex: this.currentIndex }; this.onFrameUpdate(state); this.animationFrameId = requestAnimationFrame(this._loop.bind(this)); }
            _interpolate(frame1, frame2, t) { if (t <= 0) return frame1; if (t >= 1) return frame2; const lerp = (p1, p2, t) => ({ x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t, z: (p1.z ?? 0) + ((p2.z ?? 0) - (p1.z ?? 0)) * t, }); let interpolatedBody = frame1.body; if (frame1.body && frame1.body.length > 0 && frame2.body && frame2.body.length === frame1.body.length) { interpolatedBody = frame1.body.map((p, i) => lerp(p, frame2.body[i], t)); } const interpolatedHands = [...(frame1.hands || [null, null])]; if (frame1.hands && frame2.hands) { if (frame1.hands[0] && frame2.hands[0] && frame1.hands[0].length === frame2.hands[0].length) { interpolatedHands[0] = frame1.hands[0].map((p, i) => lerp(p, frame2.hands[0][i], t)); } if (frame1.hands[1] && frame2.hands[1] && frame1.hands[1].length === frame2.hands[1].length) { interpolatedHands[1] = frame1.hands[1].map((p, i) => lerp(p, frame2.hands[1][i], t)); } } return { ...frame1, timestamp: frame1.timestamp + (frame2.timestamp - frame1.timestamp) * t, body: interpolatedBody, hands: interpolatedHands, }; }
        }
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('jsonFile'); const fileNameSpan = document.getElementById('fileName'); const playPauseBtn = document.getElementById('playPauseBtn'); const playIcon = document.getElementById('playIcon'); const pauseIcon = document.getElementById('pauseIcon'); const replayBtn = document.getElementById('replayBtn'); const prevFrameBtn = document.getElementById('prevFrameBtn'); const nextFrameBtn = document.getElementById('nextFrameBtn'); const scrubber = document.getElementById('timelineScrubber'); const speedControl = document.getElementById('speedControl'); const canvas = document.getElementById('motionCanvas'); const bodyStreamCheck = document.getElementById('bodyStream'); const handsStreamCheck = document.getElementById('handsStream'); const faceStreamCheck = document.getElementById('faceStream'); const mirrorModeCheck = document.getElementById('mirrorMode'); const exportBtn = document.getElementById('exportBtn'); const statusText = document.getElementById('statusText'); const timeText = document.getElementById('timeText'); const frameText = document.getElementById('frameText'); const themeToggle = document.getElementById('themeToggle'); const canvasWrapper = document.querySelector('.canvas-wrapper'); const fullscreenBtn = document.getElementById('fullscreenBtn'); const playerControls = document.querySelector('.player-controls');
            let motionData = []; let isScrubbing = false; let controlsTimeout;
            const renderer = new Renderer(canvas); const scheduler = new Scheduler(onFrameUpdate, updatePlaybackUI);
            const currentTheme = localStorage.getItem('theme') || 'dark'; document.documentElement.setAttribute('data-theme', currentTheme);
            themeToggle.addEventListener('click', () => { let theme = document.documentElement.getAttribute('data-theme'); theme = (theme === 'dark') ? 'light' : 'dark'; document.documentElement.setAttribute('data-theme', theme); localStorage.setItem('theme', theme); scheduler.redrawCurrentFrame(); });
            fullscreenBtn.addEventListener('click', () => { if (!document.fullscreenElement) { canvasWrapper.requestFullscreen().catch(err => alert(`Error: ${err.message}`)); } else { document.exitFullscreen(); } });
            function showControls() { clearTimeout(controlsTimeout); playerControls.classList.remove('hidden'); controlsTimeout = setTimeout(() => playerControls.classList.add('hidden'), 3000); }
            canvasWrapper.addEventListener('mousemove', showControls); canvasWrapper.addEventListener('click', showControls); canvasWrapper.addEventListener('mouseleave', () => clearTimeout(controlsTimeout));
            function updatePlaybackUI() { playIcon.classList.toggle('hidden', scheduler.isPlaying); pauseIcon.classList.toggle('hidden', !scheduler.isPlaying); playPauseBtn.title = scheduler.isPlaying ? 'Pause' : 'Play'; const hasData = motionData.length > 0; [playPauseBtn, replayBtn, prevFrameBtn, nextFrameBtn, scrubber, exportBtn, speedControl, fullscreenBtn].forEach(el => el.disabled = !hasData); if (hasData) { playerControls.classList.remove('hidden'); showControls(); } else { playerControls.classList.add('hidden'); } }
            function onFrameUpdate(state) { if (!state.currentFrame) return; const renderOptions = { drawBody: bodyStreamCheck.checked, drawHands: handsStreamCheck.checked, drawFace: faceStreamCheck.checked, mirror: mirrorModeCheck.checked, }; renderer.drawFrame(state.currentFrame, renderOptions); updateUI(state); }
            function updateUI(state) { const totalSeconds = state.currentTime / 1000; const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0'); const seconds = (totalSeconds % 60).toFixed(3).padStart(6, '0'); timeText.textContent = `Time: ${minutes}:${seconds}`; frameText.textContent = `Frame: ${state.currentIndex + 1} / ${motionData.length}`; if (!isScrubbing) { scrubber.value = state.currentIndex; } }
            function handleFileLoad(event) { const file = event.target.files[0]; if (!file) return; fileNameSpan.textContent = file.name; const reader = new FileReader(); reader.onload = (e) => { try { const parsedJson = JSON.parse(e.target.result); let rawFrames; if (typeof parsedJson === 'object' && parsedJson !== null && Array.isArray(parsedJson.frames)) { rawFrames = parsedJson.frames; } else { throw new Error("JSON does not contain a 'frames' array."); } if (rawFrames.length > 0 && typeof rawFrames[0].timestamp === 'undefined') { throw new Error("Invalid MIMICA data structure."); } motionData = rawFrames.map(frame => { const hands = frame.hands || []; return { timestamp: frame.timestamp, body: frame.pose || null, hands: [hands[0] || null, hands[1] || null], face: frame.expression || null, }; }); scheduler.loadData(motionData); scrubber.max = motionData.length > 0 ? motionData.length - 1 : 0; statusText.textContent = `Loaded ${file.name}. Ready to play.`; handleStop(); } catch (error) { alert("Error loading file.\n\n" + error.message); console.error(error); } }; reader.readAsText(file); }
            function handlePlayPause() { if (scheduler.isPlaying) { scheduler.pause(); statusText.textContent = "Paused."; } else { scheduler.play(); statusText.textContent = "Playing..."; } }
            function handleStop() { scheduler.stop(); statusText.textContent = "Stopped. Ready to play."; }
            async function handleExport() { if (!motionData || motionData.length === 0) { alert("Please load a file first."); return; } statusText.textContent = "Exporting..."; exportBtn.disabled = true; const chunks = []; const stream = canvas.captureStream(30); const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); recorder.ondataavailable = e => chunks.push(e.data); recorder.onstop = () => { const blob = new Blob(chunks, { type: 'video/webm' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'motion-replay.webm'; a.click(); URL.revokeObjectURL(url); a.remove(); statusText.textContent = "Export complete."; exportBtn.disabled = false; }; recorder.start(); scheduler.playFromStart(() => { recorder.stop(); }); }
            fileInput.addEventListener('change', handleFileLoad); playPauseBtn.addEventListener('click', handlePlayPause); replayBtn.addEventListener('click', handleStop); prevFrameBtn.addEventListener('click', () => scheduler.seek(scheduler.currentIndex - 1)); nextFrameBtn.addEventListener('click', () => scheduler.seek(scheduler.currentIndex + 1)); speedControl.addEventListener('change', (e) => scheduler.setSpeed(parseFloat(e.target.value))); scrubber.addEventListener('mousedown', () => isScrubbing = true); scrubber.addEventListener('mouseup', () => { isScrubbing = false; showControls(); }); scrubber.addEventListener('input', (e) => scheduler.seek(parseInt(e.target.value, 10))); mirrorModeCheck.addEventListener('change', () => scheduler.redrawCurrentFrame()); bodyStreamCheck.addEventListener('change', () => scheduler.redrawCurrentFrame()); handsStreamCheck.addEventListener('change', () => scheduler.redrawCurrentFrame()); faceStreamCheck.addEventListener('change', () => scheduler.redrawCurrentFrame()); exportBtn.addEventListener('click', handleExport); window.addEventListener('resize', () => renderer.resizeCanvas());
            updatePlaybackUI();
            renderer.resizeCanvas();
        });
    </script>
</body>
</html>
